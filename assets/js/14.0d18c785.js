(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{373:function(n,s,a){"use strict";a.r(s);var e=a(42),t=Object(e.a)({},(function(){var n=this,s=n.$createElement,a=n._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[n._v("#")]),n._v(" 背景")]),n._v(" "),a("p",[n._v("在 win10 16299 和以前，虽然也支持多窗口导航，但那些窗口都是在同一个"),a("code",[n._v("App")]),n._v("对象中生成，也就是每个窗口都对应一个"),a("code",[n._v("CoreApplicationView")]),n._v("。")]),n._v(" "),a("h2",{attrs:{id:"功能支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#功能支持"}},[n._v("#")]),n._v(" 功能支持")]),n._v(" "),a("p",[n._v("但 17069 及以上现在才算真正支持了多窗口，因为在新版本中，增加了"),a("code",[n._v("AppInstance")]),n._v("这个类，也就是类似于 Win32 下的窗口句柄，可以实现每个窗口对应一个"),a("code",[n._v("App")]),n._v("对象，"),n._v("或者每个窗口对应一个窗口句柄。当然，以前的"),a("code",[n._v("CoreApplicationView")]),n._v("窗口功能也没有改变。")]),n._v(" "),a("p",[n._v("在这个新功能的前提下，真正的多窗口才可以实现。比如每次运行一个文件，都要打开一个新窗口；再次运行这个文件时，激活之前打开对应的窗口。但这又不能在 App.xaml.cs 中解决，因为每次生成窗口，都对应一个"),a("code",[n._v("App")]),n._v("对象，也就是说在 App.xaml.cs 中的"),a("code",[n._v("App")]),n._v("对象是在这个窗口中生成。这该怎么解决呢？\n看看"),a("code",[n._v("App")]),n._v("类中的构造函数：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    /// &lt;summary&gt;\n    /// 初始化单一实例应用程序对象。这是执行的创作代码的第一行，\n    /// 已执行，逻辑上等同于 main() 或 WinMain()。\n    /// &lt;/summary&gt;\n    public App()\n    {\n        this.InitializeComponent();\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br")])]),a("p",[n._v("肯定会有不少人认为，这个就是 UWP 的入口，因为官方文档就这样介绍，而且注释说的也很清楚。其实不然，学 C#的都知道，程序入口就在"),a("code",[n._v("Main()")]),n._v("函数，UWP 也不例外，但 UWP 的"),a("code",[n._v("Main()")]),n._v("在哪呢？如果你尝试在解决方案下新建一个 Program 类，编译器就会提示你已经有过该类，于是用 F12 找到 Program 的定义处，是在 App.g.i.cs 文件中，并且该类中还有"),a("code",[n._v("Main()")]),n._v("函数，这就是 UWP 程序真正的入口点了，主函数如下：")]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    static void Main(string[] args)\n    {\n        Windows.UI.Xaml.Application.Start((p) = new App());\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br")])]),a("p",[n._v("可以看到，每次程序运行，主函数都新建一个"),a("code",[n._v("App")]),n._v("对象。因此我们如果想要实现打开新"),a("strong",[n._v("文件就新建窗口、打开已经打开的文件就激活对应窗口")]),n._v("，需要在"),a("code",[n._v("Main")]),n._v("函数中做文章。但是这又出现新的问题：App.g.i.cs 是编译器自动创建和修改，我们怎么才能控制"),a("code",[n._v("Main")]),n._v("函数呢？那么我们就让编译器不要自动生成，由我们自己生成。这需要做以下操作：")]),n._v(" "),a("ol",[a("li",[n._v("右键单击解决方案")]),n._v(" "),a("li",[n._v("点击"),a("strong",[n._v("属性")])]),n._v(" "),a("li",[n._v("在"),a("strong",[n._v("条件编译符号")]),n._v("中加上"),a("code",[n._v("DISABLE_XAML_GENERATED_MAIN;")]),n._v('。注意每项之间用”;"分隔。')]),n._v(" "),a("li",[n._v("在解决方案下新建 Program 类")]),n._v(" "),a("li",[n._v("在该类中写上主函数，如下：")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('static void Main(string[] args)\n{\n    //获得所有窗口句柄\n    instances = AppInstance.GetInstances();\n    //程序被激活\n\n    IActivatedEventArgs activatedArgs = AppInstance.GetActivatedEventArgs();\n    //如果程序由文件激活（即打开关联文件）\n    if (activatedArgs is FileActivatedEventArgs fileArgs)\n    {\n        //如果运行多个文件，在这里仅打开第一个。也可以用循环打开多个\n        IStorageItem file = fileArgs.Files.FirstOrDefault();\n        if (file != null)\n        {\n            //查询或注册句柄，这里用文件路径作为Key，可以查询文件是否已经被打开\n            var instance = AppInstance.FindOrRegisterInstanceForKey(file.Path);\n            if (instance.IsCurrentInstance)\n            {\n                //如果文件没有被打开，则新建一个App对象。对应就打开一个新的窗口\n                Windows.UI.Xaml.Application.Start((p) =&gt; new App());\n            }\n            else\n            {\n                // 如果文件已经被打开，则利用这个句柄来激活打开该文件的窗口\n                instance.RedirectActivationTo();\n            }\n        }\n    }\n    else\n    {\n        //如果程序不是由文件激活，即直接运行程序。先注册一个句柄，在MainPage.cs中，要为打开的文件修改窗口句柄，以实现再次打开文件激活窗口\n        AppInstance.FindOrRegisterInstanceForKey("REUSABLE" + App.Id.ToString());\n        Windows.UI.Xaml.Application.Start((p) =&gt; new App());\n    }\n}\n')])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br"),a("span",{staticClass:"line-number"},[n._v("17")]),a("br"),a("span",{staticClass:"line-number"},[n._v("18")]),a("br"),a("span",{staticClass:"line-number"},[n._v("19")]),a("br"),a("span",{staticClass:"line-number"},[n._v("20")]),a("br"),a("span",{staticClass:"line-number"},[n._v("21")]),a("br"),a("span",{staticClass:"line-number"},[n._v("22")]),a("br"),a("span",{staticClass:"line-number"},[n._v("23")]),a("br"),a("span",{staticClass:"line-number"},[n._v("24")]),a("br"),a("span",{staticClass:"line-number"},[n._v("25")]),a("br"),a("span",{staticClass:"line-number"},[n._v("26")]),a("br"),a("span",{staticClass:"line-number"},[n._v("27")]),a("br"),a("span",{staticClass:"line-number"},[n._v("28")]),a("br"),a("span",{staticClass:"line-number"},[n._v("29")]),a("br"),a("span",{staticClass:"line-number"},[n._v("30")]),a("br"),a("span",{staticClass:"line-number"},[n._v("31")]),a("br"),a("span",{staticClass:"line-number"},[n._v("32")]),a("br"),a("span",{staticClass:"line-number"},[n._v("33")]),a("br"),a("span",{staticClass:"line-number"},[n._v("34")]),a("br"),a("span",{staticClass:"line-number"},[n._v("35")]),a("br")])]),a("ol",{attrs:{start:"6"}},[a("li",[n._v("如果是通过文件打开新程序，在 App.cs 中还要加上一个函数：")])]),n._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    protected override void OnFileActivated(FileActivatedEventArgs args)\n    {\n        Frame rootFrame = Window.Current.Content as Frame;\n        if (rootFrame == null)\n        {\n            rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n        }\n\n        StorageFile file = args.Files.FirstOrDefault() as StorageFile;\n        if (rootFrame.Content == null)\n        {\n            rootFrame.Navigate(typeof(MainPage), file);\n        }\n        Window.Current.Activate();\n    }\n")])]),n._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[n._v("1")]),a("br"),a("span",{staticClass:"line-number"},[n._v("2")]),a("br"),a("span",{staticClass:"line-number"},[n._v("3")]),a("br"),a("span",{staticClass:"line-number"},[n._v("4")]),a("br"),a("span",{staticClass:"line-number"},[n._v("5")]),a("br"),a("span",{staticClass:"line-number"},[n._v("6")]),a("br"),a("span",{staticClass:"line-number"},[n._v("7")]),a("br"),a("span",{staticClass:"line-number"},[n._v("8")]),a("br"),a("span",{staticClass:"line-number"},[n._v("9")]),a("br"),a("span",{staticClass:"line-number"},[n._v("10")]),a("br"),a("span",{staticClass:"line-number"},[n._v("11")]),a("br"),a("span",{staticClass:"line-number"},[n._v("12")]),a("br"),a("span",{staticClass:"line-number"},[n._v("13")]),a("br"),a("span",{staticClass:"line-number"},[n._v("14")]),a("br"),a("span",{staticClass:"line-number"},[n._v("15")]),a("br"),a("span",{staticClass:"line-number"},[n._v("16")]),a("br")])]),a("h2",{attrs:{id:"说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[n._v("#")]),n._v(" 说明")]),n._v(" "),a("p",[n._v("App.cs 中 OnFileActivated 函数和"),a("code",[n._v("OnLaunched")]),n._v("类似，也是在构建 App 对象之后运行该函数。不同之处在于当程序由文件激活时（也就是打开关联文件，并新建"),a("code",[n._v("App")]),n._v("对象时），程序运行"),a("code",[n._v("OnFileActivated")]),n._v("而不是"),a("code",[n._v("OnLaunched")]),n._v("。在这个函数中，可以对文件进行操作。")])])}),[],!1,null,null,null);s.default=t.exports}}]);